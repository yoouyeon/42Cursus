# 🌟 CPP Module 07

과제를 하면서 공부한 내용들(을 엄청 대충 정리함)

## 🌸 함수 템플릿

템플릿이란 어떤 틀을 말한다.

함수 템플릿이란, 함수를 만드는 틀이라고 할 수 있다. 비슷한 모양의 함수가 여러 개 필요하다면, 틀을 만들어놓고, 그 틀을 이용해서 필요한 형태로 함수를 찍어내는 것이다.

함수 템플릿 정의 형식은 `template` 키워드로 시작하고, `<>` 괄호 안에 타입 인수임을 의미하는 `typename` 키워드와 그 아래부터 사용할 타입 인수의 이름을 적는다. (보통 타입 인수의 이름은 `T`를 사용한다.)

만약에 템플릿 함수를 호출할 때 `int`를 사용하면, 타입 인수인 `T`는 `int`가 된다. `std::string`을 사용하면, 타입인수 `T`는 `std::string` 타입이 된다.

## 🌸 템플릿의 동작 방식

### 🌱 템플릿의 동작 방식

컴파일러는 템플릿 메소드를 정의하는 코드를 발견하면, 문법 검사만 하고 템플릿 코드를 실제로 컴파일하지 않는다. 단순히 선언만 보고는 실제로 어떤 타입을 사용할 지 알 수 없기 때문이다.

컴파일러가 템플릿을 인스턴스화(구체화) 하는 코드를 발견하면 (`myTemplate<int>` 이런 식으로) 템플릿의 타입인수였던 `T` 에 `int`를 대입해서 `int` 타입의 클래스를 생성한다. 다른 타입의 구체화 코드를 발견하면 또 만든다.

단순하게 생각하면 복사해서 붙여넣고 타입만 바꾸어서 여러 타입의 클래스를 만드는 단순반복 작업을 템플릿이라는 기능으로 편하게 만든 것이라고 생각하면 편하다.

클래스 템플릿을 정의하는 코드만 작성하고, 인스턴스화 코드를 작성하지 않으면, 클래스를 정의하는 코드는 컴파일되지 않는다.

### 🌱 템플릿 선언과 구현 모두 헤더파일에 하는 이유

템플릿 클래스는 단지 클래스를 찍어내기 위한 틀이다.

컴파일러는 파일 단위를 컴파일을 하는데, 그 대상은 오직 cpp파일이고, 템플릿 클래스를 cpp 파일에 넣어두면 컴파일러가 그 cpp 파일을 컴파일 하려고 할 때, T가 실제로 어떤 타입으로 변환되는지 알 수가 없어서 (구체화 코드를 찾을 수 없음) 에러가 나게 된다.

따라서 컴파일러에게 한방에 그 템플릿에 대한 모든 정보를 알려주기 위해서 헤더파일에다가 선언과 구현을 모두 하는 것이다.

근데 만약에 구현부가 너무 길어 가독성이 좋지 않다면, 파일을 나눈 것이 더 좋을 수 있는데 이때는 컴파일러가 컴파일을 시도하는 cpp 파일이 아닌 다른 확장자를 가지는 파일에 구현을 해 주면 되고, 일반적으로는 template의 구현을 하는 파일이라고 해서 tpp라는 확장자를 가지는 파일에 구현을 한다고 한다.

참고 : <https://stackoverflow.com/questions/44774036/why-use-a-tpp-file-when-implementing-templated-functions-and-classes-defined-i>
