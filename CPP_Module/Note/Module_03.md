# 🌟 CPP Module 03

과제를 하면서 공부한 내용들

## 🌸 상속

이미 정의한 클래스의 멤버를 물려받아서 새로운 클래스를 정의하는 것을 상속이라고 한다. 클래스는 저번에 구조체의 확장(?)이라고 했으니, 구조체 역시도 상속하고, 상속받을 수 있다. ([참고](https://blog.naver.com/PostView.nhn?isHttpsRedirect=true&blogId=ghostcbr954&logNo=110003736593&redirect=Dlog&widgetTypeCall=true))

상속을 하게 되면 기존 클래스를 재활용하고, 반복되는 부분을 상위 클래스에 통합할 수 있어 반복 작업을 줄일 수 있어 생산성이 높아지고, 공동의 조상을 가지는 클래스들의 계층을 형성해서 다형성을 구현할 수 있다는 장점이 있다.

상속하는 방법

```cpp
class 자식클래스 : public 부모클래스
{
	추가 멤버 선언
};
```
자식클래스에서는 부모 클래스의 public과 protected 멤버에 접근할 수 있고, 추가적인 멤버 선언도 가능하다.

부모의 private 멤버는 자식클래스에서도 접근할 수 없다. 따라서 자식클래스에서 상속받아서 사용해야 하는 부모의 멤버는 자식에서만 접근할 수 있도록 protected로 선언해줘야 한다.

### 🌱 상속 접근 지정자

상속받은 멤버들의 접근 레벨을 어떻게 할 지 지정하는 부분이다. 일반적으로는 public으로 상속하지만 기본값은 private이다. 당연한 이야기지만 부모 클래스에서 private이었던 것은 상속 접근 지정자와 상관 없이 무조건 private이 된다.

- public : 기반(부모) 클래스의 접근 속성이 그대로 유지된다.
- private : 기반(부모) 클래스에서 public, protected 속성이었던 것들이 모두 private 속성이 된다.
- protected : 기반(부모) 클래스에서 public 속성이었던 것들이 protected 속성이 된다. (기존 protected 속성은 그대로 유지)

### 🌱 멤버 함수 오버라이딩

- 생성자와 소멸자
- 대입연산자
- static 멤버
- Friend 관계 지정

위 4가지는 특정 클래스의 고유한 처리를 담당하기 때문에 상속이 되지 않는다. 이 외에는 모두 자식 클래스로 무조건 상속이 된다. (특정 멤버만 상속받을수는 없다.) 만약에 필요 없는 것이 상속된다면 자식에서는 2가지 선택지를 가질 수 있다.

- 무시한다. (안쓰면 된다.)
- 원형은 같지만 다른 방식으로 필요하다면 재정의 (오버라이딩)

부모의 멤버함수와 원형은 같지만 다른 내용의 함수를 선언해주면 된다.

이렇게 되면 부모의 멤버함수와 자식의 멤버함수 이렇게 2개의 함수를 자식이 갖게 되는데 이름이 중복되면 지역으로 선언된 자식의 멤버함수가 우선권을 갖게 되어 상속받은 부모의 멤버함수는 숨겨지게 된다. 만약에 오버라이딩 전 부모의 멤버함수를 호출하고 싶을 때에는 :: 연산자(?)로 부모클래스 소속의 함수임을 표시해주면 된다.

### 🌱 다중 상속

### 🌱 참고

- [C++ 트레이닝](https://www.hanbit.co.kr/store/books/look.php?p_code=B7818919239)

## 🌸 다형성 (가상 함수)

~~필수적인 내용은 아니지만 함수 상속 후 오버라이딩을 해야 하는 상황이고, 평가 중 발생할 수 있는 예상치 못한 상황(ex. fail..ㅜ)을 원천차단하기 위해서 (...) 미리 공부해둠. 본격적인 내용은 Module 04에 등장~~

