# 2022.05.21

## 해야 할 일

- [x] 서브젝트 이해하기
- [x] 허용 함수 공부하기
- [ ] Thread 공부하기
- [ ] 동기화 공부하기 (Mutex, Semaphore 간단히)
- [ ] 프로그램 설계하기
- [ ] 코드 작성하기
  - [ ] main

## Thread

```c
// pthread_join

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

void	*func(void *data)
{
	printf("%s\n", data);
	usleep(1000000);
	printf("Exit Thread no.0\n");
	return (0);
}

int	main(void)
{
	pthread_t		thread[3];
	int				ret;

	ret = pthread_create(&thread[0], NULL, func, "Hi! I'm Thread no.0");
	if (ret != 0)
		printf("Failed to create thread(0)\n");
	usleep(100000);
	pthread_join(thread[0], ret);
	printf("Exit main()\n");
	return (0);
}
```

인자들 타입 안맞아서 warning뜨는데 일단 무시하자

![pthread_join 있는 경우](./img/screenrecord_pthread_join_test_1.gif)

func가 실행되고 종료된 뒤에 main 함수의 마지막 printf가 실행된다.

pthread_join 라인을 주석처리해서 실행하면

![pthread_join 없는 경우](./img/screenrecord_pthread_join_test_2.gif)

func 함수의 실행시간이 1000000ms 이상이기 때문에 그냥 바로 main함수가 종료되어버린다.

---

일반적으로 스레드가 종료되면 자원이 계속 남아있게 된다. (메모리 누수!!!!!) join으로 종료를 하게 되면 종료를 기다린 스레드에 대한 메모리는 모두 회수가 된다고 하는데, 종료까지 기다리지 않고도 pthread_detach 함수로 생성 이후에 detach 시켜주면 굳이 기다리지 않아도 그 스레드는 종료 후에 알아서 메모리를 해제한다.

```c
// pthread_detach

int	main(void)
{
	pthread_t		thread[3];
	int				ret;

	ret = pthread_create(&thread[0], NULL, func, "Hi! I'm Thread no.0");
	if (ret != 0)
		printf("Failed to create thread(0)\n");
	pthread_detach(thread[0]);
	return (0);
}
```

이렇게 사용하면 된다.

## 동기화

참고 : <https://bitsoul.tistory.com/172?category=683199>

스레드는 코드 영역과 데이터 영역을 공유하기 때문에 (데이터 영역에는 전역변수, static 변수, ... 가 저장된다.) 이 공유 공간에 저장된 것들은 스레드들이 서로 수정하려고 하면서(Data Race) 원치 않은 결과가 발생할 수 있다.

```c
#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

int num;

void *func(void *data)
{
	printf("%s start\n", data);
	num = 0;
	for(int i = 1; i <= 5; i++)
	{
		num++;
		printf("%s num: %d\n", data, num);
	}
	printf("%s end\n", data);
	return (0);
}

int main(void)
{
	pthread_t thread[2];
	int ret;

	pthread_create(&thread[0], NULL, func, "Thread no.0");
	pthread_create(&thread[1], NULL, func, "Thread no.1");
	usleep(1000000);
	printf("Exit main()\n");
	return (0);
}
```

![data_race_test](./img/screenshot_data_race_test.png)

이렇게 두번째 시도의 결과를 예상하고 짠 코드가 첫번째 시도처럼 예상치 못한 결과를 발생시킬 수 있다. 하나의 공유자원인 num에 두개의 프로세스가 접근하게 되면서 발생된 문제.

이럴 때 하나의 공유 자원에 한개의 스레드만 접근할 수 있게 하는 방법이 **Mutex**라고 한다.

### Mutex

mutual exclusion 상호배제

어떤 스레드에서 Critical Section을 실행하고 있는 경우에는 겹치지 않게, 다른 스레드들은 해당 Section에 접근할 수 없게 만드는 것이다. 앞선 스레드가 Critical Section을 벗어나야 다른 스레드가 접근할 수 있다. 이렇게 먼저 접근한 스레드가 lock을 풀어줘야 다른 스레드들이 접근할 수 있다는 것 같다.

### Mutex 함수들

```c
#include <pthread.h>

int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

`pthread_mutex_init()` 이 그 임계 영역을 초기화 하는 함수이고, `pthread_mutex_destroy()` 이 생성한 임계 영역을 해제 (free) 하는 함수이고, `pthread_mutex_lock()` 이 어떤 스레드에서 임계 영역에 접근해서 다른 스레드의 접근을 제한하는 함수, `pthread_mutex_unlock()` 이 먼저 접근했던 스레드에서 다른 스레드의 접근을 허용하기 위해서 unlock 하는 함수이다...! 오 이해됐다.

```c
// mutex lock test

#include <pthread.h>
#include <stdio.h>
#include <unistd.h>

int num;
pthread_mutex_t mutex;

void *func(void *data)
{
	printf("%s start\n", data);
  
	pthread_mutex_lock(&mutex);
  
	num = 0;
	for(int i = 1; i <= 5; i++)
	{
		num++;
		printf("%s num: %d\n", data, num);
	}
	printf("%s end\n", data);
  
	pthread_mutex_unlock(&mutex);
  
	return (0);
}

int main(void)
{
	pthread_t thread[2];
	int ret;

	pthread_mutex_init(&mutex, NULL);

	pthread_create(&thread[0], NULL, func, "Thread no.0");
	pthread_create(&thread[1], NULL, func, "Thread no.1");
	usleep(1000000);
	printf("Exit main()\n");
	return (0);
}
```

![mutex_lock_test](./img/screenshot_mutex_lock_test.png)

이런 식으로 num이 섞이지 않는다.

## 해야 할 일 (Update)

- [x] 서브젝트 이해하기
- [x] 허용 함수 공부하기
- [x] Thread 공부하기
- [ ] 동기화 공부하기 (Mutex, Semaphore 간단히)
- [ ] 프로그램 설계하기
- [ ] 코드 작성하기
  - [ ] main
- [ ] 테스트
  - [ ] 테스터 돌려보기
  - [ ] 서브젝트 다시 확인하기
  - [ ] 평가표 ?
- [ ] 평가 준비
  - [ ] 개념 다시 정리
  - [ ] 코드 리뷰